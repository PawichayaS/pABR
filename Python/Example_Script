import numpy as np
import math
import random
import scipy
import scipy.interpolate as sp
import scipy.io as sio
import mat73
import matplotlib.pyplot as plt
import statistics
import sys
from scipy.io import savemat
from plotly.subplots import make_subplots
import hdf5storage
scipy.io

# This script analyses a set of pABR recordings.
# Each file "Example_Voltage_And_Triggers_X" contains the recording
# made at X dB SPL and onset indices for 1000 tones at 1, 2, 4, 8, and 16kHz.

# Extract signal and noise from raw data files

signal_list = [] 
noise_list = []

for i in range(0, 110, 10): 
    filenames = f'/Volumes/My_Passport/Go_for_Github/Example_Voltage_And_Triggers_{i}.mat'
    all_data = scipy.io.loadmat(filenames)

    voltage = all_data["voltage"]
    triggers = all_data["triggers"] 
    
    signal, noise = Extract_Signal_And_Noise(voltage, triggers, 44100, 0.08, 0.035, 32, 0, 0)
   
    signal_list.append(signal)

    noise_list.append(noise)
    
signals = np.array(signal_list) 
signals= np.moveaxis(signals, 0, 2)
   
noises = np.array(noise_list)
noises = np.moveaxis(noises, 0, 2)

combine_data = {'Signal': signals,
                'Noise': noises}

hdf5storage.savemat('Example_Signal_And_Noise.mat', combine_data, format = 7.3, matlab_compatible = True, compress = True)

## Analyze signal and noise and estimate threshold ##

tot_var,noise_var,log_tot_var,mean_log_noise_var,std_log_noise_var,snr_std = Analyze_Signal_And_Noise(signal, noise) 

variables_data = {
    'tot_var': tot_var,
    'noise_var': noise_var,
    'log_tot_var': log_tot_var,
    'mean_log_noise_var': mean_log_noise_var,
    'std_log_noise_var': std_log_noise_var,
    'snr_std': snr_std
    }

#save as mat file names the "Example_Signal_And_Noise_Analysis.mat" with variable_data set 
savemat('Example_Signal_And_Noise_Analysis.mat', variables_data)

levels = np.arange(0, 101, 10)  #Sound levels in dB SPL for each recording
freqs = np.array([1, 2, 4, 8, 16]) #pABR tone frequencies

std_thresh = 4.264  #Corresponding to p < 1e-5

# Interpolate to 1 dB resolution
interp_func = sp.interp1d(levels, snr_std, axis=1)
temp = interp_func(np.arange(levels[0], levels[-1] + 1))

# Plot figure
thresh = []

plt.figure(figsize=(20, 8))
for i_freq, freq in enumerate(freqs):
    thresh_level = np.argmax(temp[:, i_freq] > std_thresh) + levels[0]
    thresh.append(thresh_level)

    plt.subplot(1, len(freqs), i_freq + 1)
    plt.plot(levels, snr_std[i_freq, :], label='SNR Std')
    plt.axhline(y=std_thresh, color='r', linestyle='--', label='Threshold')
    plt.axvline(x=thresh_level, color='g', linestyle='--', label='Threshold Level')
    plt.plot(thresh_level, 0, 'o', label=f'Threshold @ {thresh_level} dB')
    plt.ylim([-2, 22])
    plt.xlabel('Sound Level (dB SPL)')
    plt.ylabel('Amplitude')
    plt.title(f'Frequency: {freq} kHz')
    plt.legend()

plt.suptitle('ABR amplitude expressed as standard deviations above amplitude expected by chance')
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()



    



